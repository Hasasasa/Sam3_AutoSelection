<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>SAM 3 Auto Selection</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <link rel="stylesheet" href="css/web.css" />
  </head>
  <body>
    <div class="app-root">
      <header>
        <div class="logo">
          <img src="icon/icon.png" alt="Logo" class="logo-icon" />
          <span>SAM 3 <span class="accent">Auto Selection</span></span>
        </div>

        <div class="toolbar">
        <div class="inputs-row">
          <div>
            <div class="field-label">åç«¯æ¨¡å‹åœ°å€</div>
            <div class="server-input-wrapper">
              <input
                id="serverInput" 
                type="text"
                value="http://localhost:8000"
                spellcheck="false"
              />
              <span id="serverStatus" class="status-dot offline"></span>
            </div>
          </div>

          <div>
            <div class="field-label">Sam3 æ¨¡å‹åœ°å€</div>
            <input
              id="modelPathInput"
              type="text"
              value="D:/HF_DATA/sam3"
              spellcheck="false"
              placeholder="SAM æ¨¡å‹è·¯å¾„ï¼Œä¾‹å¦‚ D:/HF_DATA/sam3"
            />
            </div>
          </div>
        </div>

        <div>
          <button id="uploadButton">ä¸Šä¼ å›¾ç‰‡</button>
          <button id="retryPrecomputeButton" disabled>é‡è¯•é¢„å¤„ç†</button>
          <input id="fileInput" type="file" accept="image/*" />
        </div>
      </header>

      <main>
        <div class="canvas-container" id="canvasContainer">
          <div class="placeholder" id="placeholder">
            <div class="hand">ğŸ–±ï¸</div>
            <div class="placeholder-text">UPLOAD TO START</div>
          </div>

          <div class="canvas-wrapper hidden" id="canvasWrapper">
            <img id="baseImage" alt="Base" />
            <img id="overlayImage" alt="" />
            <img id="fixedOverlay" alt="" />
          </div>
        </div>

        <aside class="side-panel">
          <div class="panel-title">Mode</div>
          <div class="mode-group">
            <button class="mode-button active" id="modeHover" data-mode="hover">æ‚¬åœé€‰å–</button>
            <button class="mode-button" id="modeClick" data-mode="click">ç‚¹å‡»åˆ†å‰²</button>
            <button class="mode-button" id="modeText" data-mode="text">æ–‡å­—åˆ†å‰²</button>
          </div>

          <div id="textControls" class="hidden">
            <div class="field-label" style="margin-top: 8px">æ–‡æœ¬æç¤ºï¼ˆè‹±æ–‡é€—å·åˆ†éš”ï¼‰</div>
            <textarea id="promptInput" placeholder="ä¾‹å¦‚: car, wheel"></textarea>
            <button id="runTextButton">è¿è¡Œæ–‡å­—åˆ†å‰²</button>
          </div>

          <div>
            <div class="field-label" style="margin-top: 8px">çŠ¶æ€</div>
            <div id="status">ç­‰å¾…ä¸Šä¼ å›¾ç‰‡...</div>
          </div>
        </aside>
      </main>

      <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-content">
           <img src="icon/icon.png" alt="Loading" class="loading-icon" />
          <div class="loading-text">æ­£åœ¨ä¸Šä¼ å¹¶å¤„ç†å›¾ç‰‡...</div>
        </div>
      </div>
    </div>

    <script>
      const serverInput = document.getElementById("serverInput");
      const serverStatus = document.getElementById("serverStatus");
      const modelPathInput = document.getElementById("modelPathInput");
      const uploadButton = document.getElementById("uploadButton");
      const retryPrecomputeButton = document.getElementById("retryPrecomputeButton");
      const fileInput = document.getElementById("fileInput");
      const baseImage = document.getElementById("baseImage");
      const overlayImage = document.getElementById("overlayImage");
      const fixedOverlay = document.getElementById("fixedOverlay");
      const placeholder = document.getElementById("placeholder");
      const canvasWrapper = document.getElementById("canvasWrapper");
      const statusEl = document.getElementById("status");
      const modeButtons = document.querySelectorAll(".mode-button");
      const promptInput = document.getElementById("promptInput");
      const runTextButton = document.getElementById("runTextButton");
      const textControls = document.getElementById("textControls");
      const loadingOverlay = document.getElementById("loadingOverlay");
      const loadingText = loadingOverlay.querySelector(".loading-text");

      let imageId = null;
      let lastRequestId = 0;
      let currentMode = "hover";
      let lastHoverX = null;
      let lastHoverY = null;
      let hoverInFlight = false;
      const HOVER_MIN_DISTANCE = 10;

      // ONNX æ‚¬åœç›¸å…³çŠ¶æ€
      let decoderSession = null;
      let emb0 = null, emb1 = null, emb2 = null;
      let shape0 = null, shape1 = null, shape2 = null;
      let onnxReady = false;
      let origH = null;
      let origW = null;
      let decoderTargetSize = 1024;
      let hoverUseOnnx = false; 
      let lastImageDataUrl = null; 

      function apiBase() {
        return serverInput.value.replace(/\/+$/, "");
      }

      function setServerOnline(online) {
        serverStatus.classList.toggle("online", online);
        serverStatus.classList.toggle("offline", !online);
      }

      function setLoading(isLoading, text) {
        if (isLoading) {
          loadingText.textContent = text || "æ­£åœ¨ä¸Šä¼ å¹¶å¤„ç†å›¾ç‰‡...";
          loadingOverlay.classList.add("visible");
        } else {
          loadingOverlay.classList.remove("visible");
        }
      }

      function clearOverlay() {
        overlayImage.src = "";
        overlayImage.style.display = "none";
        fixedOverlay.src = "";
        fixedOverlay.style.display = "none";
      }

      function flatten(arr) {
        return arr.flat(Infinity);
      }

      async function ensureDecoderSession() {
        if (decoderSession) return;
        const url = `${apiBase()}/sam3_decoder.onnx`;
        statusEl.textContent = "æ­£åœ¨ä¸‹è½½ ONNX æ¨¡å‹...";
        decoderSession = await ort.InferenceSession.create(url);
        statusEl.textContent = "ONNX æ¨¡å‹åŠ è½½å®Œæˆã€‚";
      }

      async function decodePointONNX(normPoints, normLabels) {
        if (!decoderSession || !onnxReady || !emb0) return null;

        const pts = new Float32Array(flatten(normPoints));
        const labelsFlat = flatten(normLabels).map((v) => BigInt(v));
        const lbl = new BigInt64Array(labelsFlat);

        const feeds = {};
        for (const inp of decoderSession.inputNames) {
          if (inp === "image_embedding_s0") {
            feeds[inp] = new ort.Tensor("float32", emb0, shape0);
          } else if (inp === "image_embedding_s1") {
            feeds[inp] = new ort.Tensor("float32", emb1, shape1);
          } else if (inp === "image_embedding_s2") {
            feeds[inp] = new ort.Tensor("float32", emb2, shape2);
          } else if (inp === "input_points") {
            feeds[inp] = new ort.Tensor("float32", pts, [normPoints.length, normPoints[0].length, normPoints[0][0].length, 2]);
          } else if (inp === "input_labels") {
            feeds[inp] = new ort.Tensor("int64", lbl, [normLabels.length, normLabels[0].length, normLabels[0][0].length]);
          }
        }

        const outputs = await decoderSession.run(feeds);
        return outputs["pred_masks"];
      }

      uploadButton.addEventListener("click", () => fileInput.click());

      async function processImageDataUrl(dataUrl) {
        lastImageDataUrl = dataUrl;
        baseImage.src = dataUrl;
        clearOverlay();
        placeholder.classList.add("hidden");
        canvasWrapper.classList.remove("hidden");
        statusEl.textContent = "æ­£åœ¨ä¸Šä¼ å›¾ç‰‡å¹¶é¢„å¤„ç†æ‚¬åœç‰¹å¾...";
        setLoading(true, "æ­£åœ¨ä¸Šä¼ å¹¶é¢„å¤„ç†å›¾ç‰‡ï¼Œè¯·ç¨å€™...");
        retryPrecomputeButton.disabled = true;

        try {
          const res = await fetch(`${apiBase()}/set_image`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              image_data: dataUrl,
              model_path: modelPathInput.value.trim() || null,
            }),
          });
          if (!res.ok) throw new Error(await res.text());
          const json = await res.json();
          imageId = json.image_id;
          setServerOnline(true);

          emb0 = emb1 = emb2 = null;
          shape0 = shape1 = shape2 = null;
          onnxReady = false;
          hoverUseOnnx = false;
          origH = null;
          origW = null;
          decoderTargetSize = 1024;

          statusEl.textContent = "å›¾ç‰‡å·²ä¸Šä¼ ï¼Œæ­£åœ¨é¢„å¤„ç†æ‚¬åœç‰¹å¾...";
          await ensureDecoderSession();

          const embRes = await fetch(`${apiBase()}/get_embeddings`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image_id: imageId }),
          });
          if (!embRes.ok) throw new Error(await embRes.text());
          const embJson = await embRes.json();
          const [e0, e1, e2] = embJson.embeddings;

          if (Array.isArray(embJson.original_sizes) && embJson.original_sizes.length > 0) {
            const sz = embJson.original_sizes[0];
            if (Array.isArray(sz) && sz.length >= 2) {
              origH = sz[0];
              origW = sz[1];
            }
          } else if (baseImage.naturalWidth && baseImage.naturalHeight) {
            origH = baseImage.naturalHeight;
            origW = baseImage.naturalWidth;
          }
          if (typeof embJson.target_size === "number" && embJson.target_size > 0) {
            decoderTargetSize = embJson.target_size;
          }

          shape0 = [e0.length, e0[0].length, e0[0][0].length, e0[0][0][0].length];
          shape1 = [e1.length, e1[0].length, e1[0][0].length, e1[0][0][0].length];
          shape2 = [e2.length, e2[0].length, e2[0][0].length, e2[0][0][0].length];

          emb0 = new Float32Array(flatten(e0));
          emb1 = new Float32Array(flatten(e1));
          emb2 = new Float32Array(flatten(e2));

          onnxReady = true;
          hoverUseOnnx = true;
          statusEl.textContent = "å›¾ç‰‡ä¸Šä¼ å¹¶é¢„å¤„ç†å®Œæˆï¼Œå¯ä»¥å¼€å§‹æ‚¬åœé€‰å–ã€‚";
        } catch (err) {
          console.error(err);
          setServerOnline(false);
          statusEl.textContent = "ä¸Šä¼ æˆ–é¢„å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯åœ°å€ã€æ¨¡å‹è·¯å¾„å’Œ sam3_decoder.onnxã€‚";
          retryPrecomputeButton.disabled = !lastImageDataUrl;
        } finally {
          setLoading(false);
        }
      }

      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => await processImageDataUrl(e.target.result);
        reader.readAsDataURL(file);
      });

      retryPrecomputeButton.addEventListener("click", async () => {
        if (!lastImageDataUrl) return;
        await processImageDataUrl(lastImageDataUrl);
      });

      function getRelativeCoords(event) {
          const rect = baseImage.getBoundingClientRect();
          const naturalW = baseImage.naturalWidth;
          const naturalH = baseImage.naturalHeight;
          if (!naturalW || !naturalH) return { x: 0, y: 0 };

          const scale = Math.min(rect.width / naturalW, rect.height / naturalH);
          const displayW = naturalW * scale;
          const displayH = naturalH * scale;
          const offsetX = (rect.width - displayW) / 2;
          const offsetY = (rect.height - displayH) / 2;

          let x = event.clientX - rect.left - offsetX;
          let y = event.clientY - rect.top - offsetY;

          x = Math.max(0, Math.min(displayW, x));
          y = Math.max(0, Math.min(displayH, y));

          const origX = x / scale;
          const origY = y / scale;

          return { x: Math.round(origX), y: Math.round(origY) };
        }

      baseImage.addEventListener("mousemove", (event) => {
          if (currentMode !== "hover") return;
          if (!imageId) return;
          if (!baseImage.naturalWidth || !baseImage.naturalHeight) return;
          if (!onnxReady || !hoverUseOnnx) return;

          const coords = getRelativeCoords(event);
          if (lastHoverX !== null && lastHoverY !== null) {
            const dx = coords.x - lastHoverX;
            const dy = coords.y - lastHoverY;
            const dist = Math.hypot(dx, dy);
            if (dist < HOVER_MIN_DISTANCE) return;
          }

          lastHoverX = coords.x;
          lastHoverY = coords.y;
          handleHoverOnnx(coords.x, coords.y);
        });

      baseImage.addEventListener("click", (event) => {
        if (!imageId) return;
        const coords = getRelativeCoords(event);

        if (currentMode === "click") {
            requestSegmentPoint(coords.x, coords.y);
          return;
        }

        if (currentMode === "hover") {
          if (!overlayImage.src) return;

          const fullW = baseImage.naturalWidth || overlayImage.naturalWidth;
          const fullH = baseImage.naturalHeight || overlayImage.naturalHeight;
          if (!fullW || !fullH) return;

          const fixedCanvas = document.createElement("canvas");
          fixedCanvas.width = fullW;
          fixedCanvas.height = fullH;
          const ctx = fixedCanvas.getContext("2d");
          ctx.drawImage(overlayImage, 0, 0, fullW, fullH);
          const imgData = ctx.getImageData(0, 0, fullW, fullH);
          const data = imgData.data;
          const size = fullW * fullH;

          // å®¢æˆ·ç«¯å›ºå®šé€»è¾‘ï¼šè¿™é‡Œç›´æ¥å¤åˆ¶ Canvas åƒç´ å³å¯ï¼Œå› ä¸ºç°åœ¨ Hover çš„è§†è§‰æ•ˆæœå·²ç»æ˜¯æœ€ç»ˆæ•ˆæœ
          
          ctx.putImageData(imgData, 0, 0);
          fixedOverlay.src = fixedCanvas.toDataURL("image/png");
          fixedOverlay.style.display = "block";
          overlayImage.src = "";
          overlayImage.style.display = "none";
          statusEl.textContent = `å·²å›ºå®šé€‰åŒºï¼Œåæ ‡ (${coords.x}, ${coords.y})`;
        }
      });

      // -------------------------------------------------------------
      // å‰ç«¯å›¾åƒå¤„ç†ç®—æ³•åº“
      // -------------------------------------------------------------

      function binarize(logits, w, h, threshold = 0.0) {
        const mask = new Uint8Array(w * h);
        for (let i = 0; i < w * h; i++) {
            mask[i] = logits[i] > threshold ? 1 : 0;
        }
        return mask;
      }

      function keepLargestComponent(mask, w, h) {
        const labels = new Int32Array(w * h).fill(0);
        let currentLabel = 1;
        const componentSizes = new Map();

        // BFS æ‰¾è¿é€šåŸŸ
        for (let i = 0; i < w * h; i++) {
            if (mask[i] && labels[i] === 0) {
                let count = 0;
                const queue = [i];
                labels[i] = currentLabel;
                let head = 0;
                while(head < queue.length) {
                    const idx = queue[head++];
                    count++;
                    const x = idx % w;
                    const y = Math.floor(idx / w);
                    
                    const neighbors = [];
                    if (y > 0) neighbors.push(idx - w);
                    if (y < h - 1) neighbors.push(idx + w);
                    if (x > 0) neighbors.push(idx - 1);
                    if (x < w - 1) neighbors.push(idx + 1);

                    for (const n_idx of neighbors) {
                        if (mask[n_idx] && labels[n_idx] === 0) {
                            labels[n_idx] = currentLabel;
                            queue.push(n_idx);
                        }
                    }
                }
                componentSizes.set(currentLabel, count);
                currentLabel++;
            }
        }

        let maxLabel = -1;
        let maxSize = 0;
        for (const [lbl, size] of componentSizes) {
            if (size > maxSize) { maxSize = size; maxLabel = lbl; }
        }

        const result = new Uint8Array(w * h);
        if (maxLabel !== -1) {
             for (let i = 0; i < w * h; i++) {
                if (labels[i] === maxLabel) result[i] = 1;
             }
        }
        return result;
      }

      function fillHoles(mask, w, h) {
        const floodMap = new Int32Array(w * h);
        const queue = [];

        for (let x = 0; x < w; x++) {
            if (mask[0 * w + x] === 0) { floodMap[0 * w + x] = 2; queue.push(0 * w + x); }
            if (mask[(h - 1) * w + x] === 0) { floodMap[(h - 1) * w + x] = 2; queue.push((h - 1) * w + x); }
        }
        for (let y = 1; y < h - 1; y++) {
            if (mask[y * w + 0] === 0) { floodMap[y * w + 0] = 2; queue.push(y * w + 0); }
            if (mask[y * w + (w - 1)] === 0) { floodMap[y * w + (w - 1)] = 2; queue.push(y * w + (w - 1)); }
        }

        let head = 0;
        while(head < queue.length) {
            const idx = queue[head++];
            const x = idx % w;
            const y = Math.floor(idx / w);

            const neighbors = [];
            if (y > 0) neighbors.push(idx - w);
            if (y < h - 1) neighbors.push(idx + w);
            if (x > 0) neighbors.push(idx - 1);
            if (x < w - 1) neighbors.push(idx + 1);

            for (const n_idx of neighbors) {
                if (mask[n_idx] === 0 && floodMap[n_idx] === 0) {
                    floodMap[n_idx] = 2;
                    queue.push(n_idx);
                }
            }
        }

        const result = new Uint8Array(w * h);
        for (let i = 0; i < w * h; i++) {
            if (mask[i] === 1 || floodMap[i] === 0) {
                result[i] = 1;
            }
        }
        return result;
      }

      // [æ ¸å¿ƒä¿®æ”¹] æ‰«æçº¿å¡«å…… (Scanline Fill)
      // é€»è¾‘ï¼šå¯¹æ¯ä¸€è¡Œå’Œæ¯ä¸€åˆ—è¿›è¡Œå†…éƒ¨å¡«å……ï¼Œç„¶åå–äº¤é›†ã€‚
      // è¿™èƒ½æœ‰æ•ˆå¡«è¡¥å†…éƒ¨çš„å¤æ‚ç©ºæ´ï¼Œæ¯” FloodFill æ›´å¼ºåŠ›ã€‚
      function solidifyMask(mask, w, h) {
        const fillH = new Uint8Array(w * h);
        const fillV = new Uint8Array(w * h);

        // æ°´å¹³æ‰«æå¡«å……
        for (let y = 0; y < h; y++) {
            let minX = w, maxX = -1;
            for (let x = 0; x < w; x++) {
                if (mask[y * w + x]) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                }
            }
            if (minX <= maxX) {
                for (let x = minX; x <= maxX; x++) fillH[y * w + x] = 1;
            }
        }

        // å‚ç›´æ‰«æå¡«å……
        for (let x = 0; x < w; x++) {
            let minY = h, maxY = -1;
            for (let y = 0; y < h; y++) {
                if (mask[y * w + x]) {
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                }
            }
            if (minY <= maxY) {
                for (let y = minY; y <= maxY; y++) fillV[y * w + x] = 1;
            }
        }

        const result = new Uint8Array(w * h);
        for (let i = 0; i < w * h; i++) {
            // å–äº¤é›†ï¼Œä¿ç•™ç‰©ä½“çš„æ•´ä½“å‡¸å‡¹ç»“æ„ï¼Œä½†å¡«æ»¡å†…éƒ¨ç©ºæ´
            result[i] = fillH[i] & fillV[i];
        }
        return result;
      }

      function bilinearUpscale(srcData, srcW, srcH, dstW, dstH) {
        const dstData = new Float32Array(dstW * dstH);
        const xRatio = srcW / dstW;
        const yRatio = srcH / dstH;

        for (let y = 0; y < dstH; y++) {
            for (let x = 0; x < dstW; x++) {
                const srcX = x * xRatio;
                const srcY = y * yRatio;
                
                const x0 = Math.floor(srcX);
                const y0 = Math.floor(srcY);
                const x1 = Math.min(x0 + 1, srcW - 1);
                const y1 = Math.min(y0 + 1, srcH - 1);
                
                const dx = srcX - x0;
                const dy = srcY - y0;
                
                const idx00 = y0 * srcW + x0;
                const idx10 = y0 * srcW + x1;
                const idx01 = y1 * srcW + x0;
                const idx11 = y1 * srcW + x1;
                
                const val00 = srcData[idx00];
                const val10 = srcData[idx10];
                const val01 = srcData[idx01];
                const val11 = srcData[idx11];
                
                const valTop = val00 * (1 - dx) + val10 * dx;
                const valBot = val01 * (1 - dx) + val11 * dx;
                const val = valTop * (1 - dy) + valBot * dy;
                
                dstData[y * dstW + x] = val;
            }
        }
        return dstData;
      }

      async function handleHoverOnnx(x, y) {
        if (!imageId) return;
        if (hoverInFlight) return;
        if (!onnxReady || !emb0 || !emb1 || !emb2) return;
        if (!origH || !origW || !decoderTargetSize) return;

        hoverInFlight = true;

        try {
          const sx = decoderTargetSize / origW;
          const sy = decoderTargetSize / origH;
          const nx = x * sx;
          const ny = y * sy;

          const normPoints = [[[[nx, ny]]]];
          const normLabels = [[[1]]];

          const pred = await decodePointONNX(normPoints, normLabels);
          if (!pred) {
            hoverInFlight = false;
            return;
          }

          const srcH = pred.dims[3]; // 256
          const srcW = pred.dims[4]; // 256
          const srcData = pred.data; // logits

          // --- æ”¹è¿›åçš„å¤„ç†æµæ°´çº¿ (v9: å¼ºåŒ–å¡«è¡¥ç©ºæ´) ---
          
          // 1. ä½åˆ†è¾¨ç‡ä¸‹çš„æ‹“æ‰‘æ¸…ç†
          const rawBin = binarize(srcData, srcW, srcH, 0.0);
          const cleanBin = keepLargestComponent(rawBin, srcW, srcH);
          
          // ä½¿ç”¨æ‰«æçº¿å¡«å…… (solidifyMask)
          let solidMask = solidifyMask(cleanBin, srcW, srcH);
          // å†åŠ ä¸€å±‚ FloodFill ä¿åº•
          solidMask = fillHoles(solidMask, srcW, srcH);

          // 2. å°†æ¸…ç†å¹¶å¡«è¡¥åçš„ Mask ä½œç”¨å› Logits
          const maskedLogits = new Float32Array(srcW * srcH);
          for (let i = 0; i < srcW * srcH; i++) {
              if (solidMask[i] === 1) {
                  // [æ ¸å¿ƒä¿®å¤]ï¼šå…³é”®æ­¥éª¤
                  // ä¹‹å‰çš„é—®é¢˜ï¼šå³ä½¿ solidMask å¡«è¡¥äº†ç©ºæ´ï¼Œå¦‚æœ srcData[i] è¿˜æ˜¯è´Ÿæ•°ï¼Œ
                  // é‚£ä¹ˆä¸Šé‡‡æ ·åçš„åƒç´ ä¾ç„¶æ˜¯é€æ˜çš„ã€‚
                  // ç°åœ¨çš„é€»è¾‘ï¼šå¦‚æœ Mask è¯´æ˜¯å‰æ™¯ï¼Œä½† Logits æ˜¯è´Ÿæ•°ï¼ˆè¯´æ˜æ˜¯å¡«å‡ºæ¥çš„æ´ï¼‰ï¼Œ
                  // å¼ºåˆ¶ç»™å®ƒä¸€ä¸ªé«˜ Logits å€¼ï¼ˆä¾‹å¦‚ 5.0ï¼‰ï¼ŒæŠŠå®ƒâ€œç„Šæ­»â€ã€‚
                  if (srcData[i] > 0) {
                      maskedLogits[i] = srcData[i];
                  } else {
                      maskedLogits[i] = 5.0; // å¼ºåˆ¶å¡«è¡¥å€¼
                  }
              } else {
                  maskedLogits[i] = -10.0;
              }
          }

          // 3. åŒçº¿æ€§æ’å€¼ä¸Šé‡‡æ · Logits
          const maxDim = 1024; 
          const imgAspect = (baseImage.naturalWidth || srcW) / (baseImage.naturalHeight || srcH);
          
          let dstW, dstH;
          if (imgAspect > 1) {
              dstW = maxDim;
              dstH = Math.round(maxDim / imgAspect);
          } else {
              dstH = maxDim;
              dstW = Math.round(maxDim * imgAspect);
          }

          const highResLogits = bilinearUpscale(maskedLogits, srcW, srcH, dstW, dstH);

          // 4. ç”Ÿæˆé«˜åˆ†è¾¨ç‡äºŒå€¼ Mask å’Œ æè¾¹
          const imgData = new ImageData(dstW, dstH);
          const pixels = imgData.data;

          const highResMask = new Uint8Array(dstW * dstH);
          for(let i=0; i<dstW*dstH; i++) {
              highResMask[i] = highResLogits[i] > 0.0 ? 1 : 0;
          }

          // 5. æ¸²æŸ“
          for (let y = 0; y < dstH; y++) {
            for (let x = 0; x < dstW; x++) {
                const idx = y * dstW + x;
                if (highResMask[idx] === 1) {
                    const pIdx = idx * 4;
                    
                    // ç®€å•çš„ 4 é‚»åŸŸè¾¹ç¼˜æ£€æµ‹
                    let isBorder = false;
                    if (x === 0 || x === dstW - 1 || y === 0 || y === dstH - 1) {
                        isBorder = true;
                    } else {
                        if (highResMask[idx - 1] === 0 || 
                            highResMask[idx + 1] === 0 || 
                            highResMask[idx - dstW] === 0 || 
                            highResMask[idx + dstW] === 0) {
                            isBorder = true;
                        }
                    }

                    if (isBorder) {
                        pixels[pIdx] = 255;
                        pixels[pIdx + 1] = 255;
                        pixels[pIdx + 2] = 255;
                        pixels[pIdx + 3] = 255;
                    } else {
                        pixels[pIdx] = 30;
                        pixels[pIdx + 1] = 144;
                        pixels[pIdx + 2] = 255;
                        pixels[pIdx + 3] = 166; 
                    }
                }
            }
          }

          const maskCanvas = document.createElement("canvas");
          maskCanvas.width = dstW;
          maskCanvas.height = dstH;
          const mctx = maskCanvas.getContext("2d");
          mctx.putImageData(imgData, 0, 0);

          const fullW = baseImage.naturalWidth || dstW;
          const fullH = baseImage.naturalHeight || dstH;
          
          const fullCanvas = document.createElement("canvas");
          fullCanvas.width = fullW;
          fullCanvas.height = fullH;
          const fctx = fullCanvas.getContext("2d");

          fctx.imageSmoothingEnabled = true;
          fctx.imageSmoothingQuality = "high";

          fctx.drawImage(maskCanvas, 0, 0, fullW, fullH);

          overlayImage.src = fullCanvas.toDataURL("image/png");
          overlayImage.style.display = "block";
          
        } catch (err) {
          console.error(err);
        } finally {
          hoverInFlight = false;
        }
      }

      async function requestSegmentPoint(x, y) {
        const currentRequestId = ++lastRequestId;
        statusEl.textContent = `ç‚¹å‡»åæ ‡: (${x}, ${y})ï¼Œè¯·æ±‚ä¸­...`;

        try {
          const res = await fetch(`${apiBase()}/segment_point`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image_id: imageId, x, y }),
          });
          if (!res.ok) {
            statusEl.textContent = "å½“å‰ç‚¹æœªæ£€æµ‹åˆ°ç›®æ ‡ã€‚";
            clearOverlay();
            return;
          }
          const json = await res.json();
          if (currentRequestId !== lastRequestId) return;
          overlayImage.src = json.image;
          overlayImage.style.display = "block";
          statusEl.textContent = `å·²æ›´æ–°é€‰åŒºï¼Œåæ ‡ (${x}, ${y})`;
        } catch (err) {
          console.error(err);
          setServerOnline(false);
          statusEl.textContent = "è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯ã€‚";
        }
      }

      modeButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          modeButtons.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentMode = btn.dataset.mode;
          lastRequestId++;
          hoverInFlight = false;
          textControls.classList.toggle("hidden", currentMode !== "text");
          clearOverlay();
          if (currentMode === "text") {
            statusEl.textContent = "è¾“å…¥æ–‡æœ¬æç¤ºåç‚¹å‡»â€œè¿è¡Œæ–‡å­—åˆ†å‰²â€ã€‚";
          }
        });
      });

      runTextButton.addEventListener("click", async () => {
        if (!imageId) { statusEl.textContent = "è¯·å…ˆä¸Šä¼ å›¾ç‰‡ã€‚"; return; }
        const text = promptInput.value.trim();
        if (!text) { statusEl.textContent = "æ–‡æœ¬æç¤ºä¸èƒ½ä¸ºç©ºã€‚"; return; }
        statusEl.textContent = "æ–‡å­—åˆ†å‰²ä¸­...";

        try {
          const res = await fetch(`${apiBase()}/segment_text`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image_id: imageId, text }),
          });
          if (!res.ok) { statusEl.textContent = "æ–‡å­—åˆ†å‰²å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æ—¥å¿—ã€‚"; return; }
          const json = await res.json();
          overlayImage.src = json.image;
          overlayImage.style.display = "block";
          statusEl.textContent = "æ–‡å­—åˆ†å‰²å®Œæˆã€‚";
        } catch (err) {
          console.error(err);
          setServerOnline(false);
          statusEl.textContent = "è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯ã€‚";
        }
      });
    </script>
  </body>
</html>