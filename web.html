<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>SAM 3 Auto Selection</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #020617;
        color: #e5e7eb;
      }

      .app-root {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 20px;
        background: #020617;
        border-bottom: 1px solid #111827;
      }

      .logo {
        font-weight: 700;
        font-size: 18px;
        letter-spacing: 0.04em;
      }

      .logo span.accent {
        color: #3b82f6;
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .logo-icon {
        width: 24px;
        height: 24px;
        object-fit: contain;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
        justify-content: center;
      }

      .server-input-wrapper {
        position: relative;
        display: flex;
        align-items: center;
      }

      .inputs-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #serverInput,
      #modelPathInput {
        background: #020617;
        border-radius: 6px;
        border: 1px solid #374151;
        padding: 6px 32px 6px 8px;
        min-width: 260px;
        color: #e5e7eb;
        font-size: 13px;
      }

      #serverInput:focus {
        outline: none;
        border-color: #3b82f6;
      }

      .status-dot {
        position: absolute;
        right: 8px;
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 2px solid #020617;
        box-shadow: 0 0 0 1px #020617;
      }

      .status-dot.offline {
        background: #ef4444;
      }

      .status-dot.online {
        background: #22c55e;
      }

      #uploadButton {
        background: #2563eb;
        border-radius: 999px;
        border: none;
        padding: 8px 16px;
        color: #f9fafb;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.4);
      }

      #uploadButton:hover {
        background: #1d4ed8;
      }

      #retryPrecomputeButton {
        margin-left: 8px;
        background: #2563eb;
        border-radius: 999px;
        border: none;
        padding: 8px 16px;
        color: #f9fafb;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.4);
      }

      #retryPrecomputeButton:disabled {
        background: #1f2937;
        color: #9ca3af;
        cursor: default;
        box-shadow: none;
        opacity: 0.6;
      }

      #retryPrecomputeButton:not(:disabled):hover {
        background: #1d4ed8;
      }

      #fileInput {
        display: none;
      }

      main {
        flex: 1;
        display: flex;
        padding: 12px 20px 20px;
        gap: 16px;
        overflow: hidden;
      }

      .canvas-container {
        flex: 1;
        border-radius: 12px;
        background: radial-gradient(circle at top, #111827, #020617);
        border: 1px solid #0f172a;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .placeholder {
        text-align: center;
        color: #4b5563;
      }

      .placeholder .hand {
        font-size: 72px;
        margin-bottom: 16px;
        filter: drop-shadow(0 10px 25px rgba(0, 0, 0, 0.8));
      }

      .placeholder-text {
        letter-spacing: 0.2em;
        font-size: 12px;
      }

      .canvas-wrapper {
        position: relative;
        display: inline-block;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid #1f2937;
        background: #000;
        /* å›ºå®šä¸º 16:9 æ˜¾ç¤ºåŒºåŸŸï¼ŒåŸºå‡† 1920x1080ï¼Œåœ¨çª—å£è¾ƒå°æ—¶æŒ‰æ¯”ä¾‹ç¼©æ”¾ */
        width: min(1920px, 100%);
        aspect-ratio: 16 / 9;
        max-height: calc(100vh - 160px);
      }

      #baseImage {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: contain; /* ä¿æŒå›¾ç‰‡æ¯”ä¾‹ï¼Œå±…ä¸­é“ºåœ¨ 16:9 åŒºåŸŸå†… */
      }

      #overlayImage {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        display: none;
        z-index: 2;
      }

      #fixedOverlay {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        display: none;
        z-index: 1;
      }

      .side-panel {
        width: 260px;
        border-radius: 12px;
        background: #020617;
        border: 1px solid #111827;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .panel-title {
        font-size: 13px;
        font-weight: 600;
        color: #9ca3af;
      }

      .mode-group {
        display: flex;
        gap: 6px;
      }

      .mode-button {
        flex: 1;
        border-radius: 999px;
        border: 1px solid #1f2937;
        background: #030712;
        color: #9ca3af;
        padding: 6px 8px;
        font-size: 11px;
        cursor: pointer;
      }

      .mode-button.active {
        background: #111827;
        border-color: #2563eb;
        color: #e5e7eb;
      }

      .field-label {
        font-size: 11px;
        color: #6b7280;
      }

      #promptInput {
        width: 100%;
        border-radius: 8px;
        border: 1px solid #1f2937;
        background: #020617;
        color: #e5e7eb;
        font-size: 12px;
        padding: 6px 8px;
        resize: vertical;
        min-height: 60px;
      }

      #promptInput:focus {
        outline: none;
        border-color: #3b82f6;
      }

      #runTextButton {
        margin-top: 6px;
        width: 100%;
        border-radius: 999px;
        border: 1px solid #1f2937;
        background: #111827;
        color: #e5e7eb;
        padding: 6px 8px;
        font-size: 12px;
        cursor: pointer;
      }

      #runTextButton:hover {
        background: #1f2937;
      }

      #status {
        font-size: 11px;
        color: #6b7280;
        min-height: 32px;
        border-radius: 8px;
        background: #020617;
        border: 1px solid #020617;
        padding: 6px 8px;
      }

      .hidden {
        display: none;
      }

      .loading-overlay {
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(2, 6, 23, 0.98));
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
        backdrop-filter: blur(4px);
      }

      .loading-overlay.visible {
        display: flex;
      }

      .loading-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }

      .loading-icon {
        width: 64px;       /* å›ºå®šå®½åº¦ */
        height: 64px;      /* å›ºå®šé«˜åº¦ */
        font-size: 64px;
        filter: drop-shadow(0 10px 25px rgba(0, 0, 0, 0.8));
        animation: loading-bounce 1s ease-in-out infinite;
      }

      .loading-text {
        font-size: 13px;
        letter-spacing: 0.08em;
        color: #9ca3af;
      }

      @keyframes loading-bounce {
        0% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-6px);
        }
        100% {
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="app-root">
      <header>
        <div class="logo">
          <img src="icon/icon.png" alt="Logo" class="logo-icon" />
          <span>SAM 3 <span class="accent">Auto Selection</span></span>
        </div>

        <div class="toolbar">
        <div class="inputs-row">
          <div>
            <div class="field-label">åç«¯æ¨¡å‹åœ°å€</div>
            <div class="server-input-wrapper">
              <input
                id="serverInput" 
                type="text"
                value="http://localhost:8000"
                spellcheck="false"
              />
              <span id="serverStatus" class="status-dot offline"></span>
            </div>
          </div>

          <div>
            <div class="field-label">Sam3 æ¨¡å‹åœ°å€</div>
            <input
              id="modelPathInput"
              type="text"
              value="D:/HF_DATA/sam3"
              spellcheck="false"
              placeholder="SAM æ¨¡å‹è·¯å¾„ï¼Œä¾‹å¦‚ D:/HF_DATA/sam3"
            />
            </div>
          </div>
        </div>


        <div>
          <button id="uploadButton">ä¸Šä¼ å›¾ç‰‡</button>
          <button id="retryPrecomputeButton" disabled>é‡è¯•é¢„å¤„ç†</button>
          <input id="fileInput" type="file" accept="image/*" />
        </div>
      </header>

      <main>
        <div class="canvas-container" id="canvasContainer">
          <div class="placeholder" id="placeholder">
            <div class="hand">ğŸ–±ï¸</div>
            <div class="placeholder-text">UPLOAD TO START</div>
          </div>

          <div class="canvas-wrapper hidden" id="canvasWrapper">
            <img id="baseImage" alt="Base" />
            <img id="overlayImage" alt="" />
            <img id="fixedOverlay" alt="" />
          </div>
        </div>

        <aside class="side-panel">
          <div class="panel-title">Mode</div>
          <div class="mode-group">
            <button
              class="mode-button active"
              id="modeHover"
              data-mode="hover"
            >
              æ‚¬åœé€‰å–
            </button>
            <button class="mode-button" id="modeClick" data-mode="click">
              ç‚¹å‡»åˆ†å‰²
            </button>
            <button class="mode-button" id="modeText" data-mode="text">
              æ–‡å­—åˆ†å‰²
            </button>
          </div>

          <div id="textControls" class="hidden">
            <div class="field-label" style="margin-top: 8px">
              æ–‡æœ¬æç¤ºï¼ˆè‹±æ–‡é€—å·åˆ†éš”ï¼‰
            </div>
            <textarea
              id="promptInput"
              placeholder="ä¾‹å¦‚: car, wheel"
            ></textarea>
            <button id="runTextButton">è¿è¡Œæ–‡å­—åˆ†å‰²</button>
          </div>

          <div>
            <div class="field-label" style="margin-top: 8px">çŠ¶æ€</div>
            <div id="status">ç­‰å¾…ä¸Šä¼ å›¾ç‰‡...</div>
          </div>
        </aside>
      </main>

      <!-- å…¨å± Loadingï¼Œä½¿ç”¨åŒæ ·çš„æ‰‹å‹ icon åšåŠ¨æ•ˆ -->
      <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-content">
           <img src="icon/icon.png" alt="Loading" class="loading-icon" />
          <div class="loading-text">æ­£åœ¨ä¸Šä¼ å¹¶å¤„ç†å›¾ç‰‡...</div>
        </div>
      </div>
    </div>

    <script>
      const serverInput = document.getElementById("serverInput");
      const serverStatus = document.getElementById("serverStatus");
      const modelPathInput = document.getElementById("modelPathInput");
      const uploadButton = document.getElementById("uploadButton");
      const retryPrecomputeButton = document.getElementById("retryPrecomputeButton");
      const fileInput = document.getElementById("fileInput");
      const baseImage = document.getElementById("baseImage");
      const overlayImage = document.getElementById("overlayImage");
      const fixedOverlay = document.getElementById("fixedOverlay");
      const placeholder = document.getElementById("placeholder");
      const canvasWrapper = document.getElementById("canvasWrapper");
      const statusEl = document.getElementById("status");
      const modeButtons = document.querySelectorAll(".mode-button");
      const promptInput = document.getElementById("promptInput");
      const runTextButton = document.getElementById("runTextButton");
      const textControls = document.getElementById("textControls");
      const loadingOverlay = document.getElementById("loadingOverlay");
      const loadingText = loadingOverlay.querySelector(".loading-text");

      let imageId = null;
      let lastRequestId = 0;
      let currentMode = "hover";
      let lastHoverX = null;
      let lastHoverY = null;
      let hoverInFlight = false;
      const HOVER_MIN_DISTANCE = 10;

      // ONNX æ‚¬åœç›¸å…³çŠ¶æ€
      let decoderSession = null;
      let emb0 = null,
        emb1 = null,
        emb2 = null;
      let shape0 = null,
        shape1 = null,
        shape2 = null;
      let onnxReady = false;
      let origH = null;
      let origW = null;
      let decoderTargetSize = 1024;
      let hoverUseOnnx = false; // é¢„å¤„ç†æˆåŠŸåï¼Œåœ¨æ‚¬åœæ¨¡å¼ä¸‹å¯ç”¨ ONNX
      let lastImageDataUrl = null; // æœ€è¿‘ä¸€æ¬¡ä¸Šä¼ /å¤„ç†ä½¿ç”¨çš„å›¾ç‰‡ data URL

      function apiBase() {
        return serverInput.value.replace(/\/+$/, "");
      }

      function setServerOnline(online) {
        serverStatus.classList.toggle("online", online);
        serverStatus.classList.toggle("offline", !online);
      }

      function setLoading(isLoading, text) {
        if (isLoading) {
          loadingText.textContent = text || "æ­£åœ¨ä¸Šä¼ å¹¶å¤„ç†å›¾ç‰‡...";
          loadingOverlay.classList.add("visible");
        } else {
          loadingOverlay.classList.remove("visible");
        }
      }

      function clearOverlay() {
        overlayImage.src = "";
        overlayImage.style.display = "none";
        fixedOverlay.src = "";
        fixedOverlay.style.display = "none";
      }

      function flatten(arr) {
        return arr.flat(Infinity);
      }

      async function ensureDecoderSession() {
        if (decoderSession) return;
        const url = `${apiBase()}/sam3_decoder.onnx`;
        statusEl.textContent = "æ­£åœ¨ä¸‹è½½ ONNX æ¨¡å‹...";
        decoderSession = await ort.InferenceSession.create(url);
        statusEl.textContent = "ONNX æ¨¡å‹åŠ è½½å®Œæˆã€‚";
      }

      async function decodePointONNX(normPoints, normLabels) {
        if (!decoderSession || !onnxReady || !emb0) return null;

        const pts = new Float32Array(flatten(normPoints));
        // input_labels æ˜¯ int64ï¼Œè¿™é‡Œç”¨ BigInt64Array
        const labelsFlat = flatten(normLabels).map((v) => BigInt(v));
        const lbl = new BigInt64Array(labelsFlat);

        const feeds = {};
        for (const inp of decoderSession.inputNames) {
          if (inp === "image_embedding_s0") {
            feeds[inp] = new ort.Tensor("float32", emb0, shape0);
          } else if (inp === "image_embedding_s1") {
            feeds[inp] = new ort.Tensor("float32", emb1, shape1);
          } else if (inp === "image_embedding_s2") {
            feeds[inp] = new ort.Tensor("float32", emb2, shape2);
          } else if (inp === "input_points") {
            feeds[inp] = new ort.Tensor("float32", pts, [
              normPoints.length,
              normPoints[0].length,
              normPoints[0][0].length,
              2,
            ]);
          } else if (inp === "input_labels") {
            feeds[inp] = new ort.Tensor("int64", lbl, [
              normLabels.length,
              normLabels[0].length,
              normLabels[0][0].length,
            ]);
          }
        }

        const outputs = await decoderSession.run(feeds);
        return outputs["pred_masks"];
      }

      uploadButton.addEventListener("click", () => {
        fileInput.click();
      });

      // å…¬å…±çš„â€œä¸Šä¼ å + é¢„å¤„ç†â€æµç¨‹ï¼Œä¾›é¦–æ¬¡ä¸Šä¼ å’Œé‡è¯•æŒ‰é’®å…±ç”¨
      async function processImageDataUrl(dataUrl) {
        lastImageDataUrl = dataUrl;
        baseImage.src = dataUrl;
        clearOverlay();
        placeholder.classList.add("hidden");
        canvasWrapper.classList.remove("hidden");
        statusEl.textContent = "æ­£åœ¨ä¸Šä¼ å›¾ç‰‡å¹¶é¢„å¤„ç†æ‚¬åœç‰¹å¾...";
        setLoading(true, "æ­£åœ¨ä¸Šä¼ å¹¶é¢„å¤„ç†å›¾ç‰‡ï¼Œè¯·ç¨å€™...");
        retryPrecomputeButton.disabled = true;

        try {
          // 1. å…ˆæŠŠå›¾ç‰‡å‘ç»™åç«¯ï¼Œè·å– image_id
          const res = await fetch(`${apiBase()}/set_image`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              image_data: dataUrl,
              model_path: modelPathInput.value.trim() || null,
            }),
          });
          if (!res.ok) {
            throw new Error(await res.text());
          }
          const json = await res.json();
          imageId = json.image_id;
          setServerOnline(true);

          // æ¯æ¬¡æ›´æ¢å›¾ç‰‡æ—¶é‡ç½® ONNX çŠ¶æ€ï¼ˆdecoderSession ä¼šè¢«ç»­ç”¨ï¼‰
          emb0 = emb1 = emb2 = null;
          shape0 = shape1 = shape2 = null;
          onnxReady = false;
          hoverUseOnnx = false;
          origH = null;
          origW = null;
          decoderTargetSize = 1024;

          // 2. è‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡é¢„å¤„ç†ï¼šä¸‹è½½ decoder ONNXï¼ˆè‹¥å°šæœªåŠ è½½ï¼‰+ æå–ç‰¹å¾
          statusEl.textContent = "å›¾ç‰‡å·²ä¸Šä¼ ï¼Œæ­£åœ¨é¢„å¤„ç†æ‚¬åœç‰¹å¾...";
          await ensureDecoderSession();

          const embRes = await fetch(`${apiBase()}/get_embeddings`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image_id: imageId }),
          });
          if (!embRes.ok) {
            throw new Error(await embRes.text());
          }
          const embJson = await embRes.json();
          const [e0, e1, e2] = embJson.embeddings;

          // è®°å½•åŸå§‹å›¾åƒå°ºå¯¸å’Œ decoder ç›®æ ‡å°ºå¯¸ï¼Œåç»­åœ¨æµè§ˆå™¨ç«¯è‡ªè¡Œå½’ä¸€åŒ–ç‚¹å‡»åæ ‡
          if (Array.isArray(embJson.original_sizes) && embJson.original_sizes.length > 0) {
            const sz = embJson.original_sizes[0];
            if (Array.isArray(sz) && sz.length >= 2) {
              origH = sz[0];
              origW = sz[1];
            }
          } else if (baseImage.naturalWidth && baseImage.naturalHeight) {
            origH = baseImage.naturalHeight;
            origW = baseImage.naturalWidth;
          }
          if (typeof embJson.target_size === "number" && embJson.target_size > 0) {
            decoderTargetSize = embJson.target_size;
          }

          shape0 = [e0.length, e0[0].length, e0[0][0].length, e0[0][0][0].length];
          shape1 = [e1.length, e1[0].length, e1[0][0].length, e1[0][0][0].length];
          shape2 = [e2.length, e2[0].length, e2[0][0].length, e2[0][0][0].length];

          emb0 = new Float32Array(flatten(e0));
          emb1 = new Float32Array(flatten(e1));
          emb2 = new Float32Array(flatten(e2));

          onnxReady = true;
          hoverUseOnnx = true;

          statusEl.textContent = "å›¾ç‰‡ä¸Šä¼ å¹¶é¢„å¤„ç†å®Œæˆï¼Œå¯ä»¥å¼€å§‹æ‚¬åœé€‰å–ã€‚";
        } catch (err) {
          console.error(err);
          setServerOnline(false);
          statusEl.textContent =
            "ä¸Šä¼ æˆ–é¢„å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯åœ°å€ã€æ¨¡å‹è·¯å¾„å’Œ sam3_decoder.onnxã€‚";
          // å…è®¸ç”¨æˆ·ç‚¹å‡»â€œé‡è¯•é¢„å¤„ç†â€æŒ‰é’®é‡æ–°è·‘ä¸€æ¬¡
          retryPrecomputeButton.disabled = !lastImageDataUrl;
        } finally {
          // é¢„å¤„ç†å…¨éƒ¨ç»“æŸåå†å…³é—­ loading
          setLoading(false);
        }
      }

      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
          const dataUrl = e.target.result;
          await processImageDataUrl(dataUrl);
        };
        reader.readAsDataURL(file);
      });

      // é¦–æ¬¡ä¸Šä¼ å¤±è´¥åï¼Œå¯é€šè¿‡æ­¤æŒ‰é’®é‡å¤è§¦å‘â€œä¸Šä¼  + é¢„å¤„ç†â€æµç¨‹
      retryPrecomputeButton.addEventListener("click", async () => {
        if (!lastImageDataUrl) return;
        await processImageDataUrl(lastImageDataUrl);
      });

      function getRelativeCoords(event) {
          const rect = baseImage.getBoundingClientRect();
          const naturalW = baseImage.naturalWidth;
          const naturalH = baseImage.naturalHeight;
          if (!naturalW || !naturalH) {
            return { x: 0, y: 0 };
          }

          // ç”±äºä½¿ç”¨ object-fit: containï¼Œå›¾ç‰‡ä¼šåœ¨ 16:9 ç”»å¸ƒä¸­æŒ‰æ¯”ä¾‹ç¼©æ”¾å¹¶ç•™é»‘è¾¹ã€‚
          // è¿™é‡Œå…ˆç®—å‡ºå›¾ç‰‡åœ¨ç”»å¸ƒä¸­çš„å®é™…æ˜¾ç¤ºå°ºå¯¸å’Œåç§»ï¼Œå†åç®—åˆ°åŸå›¾åæ ‡ã€‚
          const scale = Math.min(rect.width / naturalW, rect.height / naturalH);
          const displayW = naturalW * scale;
          const displayH = naturalH * scale;
          const offsetX = (rect.width - displayW) / 2;
          const offsetY = (rect.height - displayH) / 2;

          let x = event.clientX - rect.left - offsetX;
          let y = event.clientY - rect.top - offsetY;

          // é˜²æ­¢ç‚¹åœ¨é»‘è¾¹åŒºåŸŸï¼Œåšä¸€ä¸‹è£å‰ª
          x = Math.max(0, Math.min(displayW, x));
          y = Math.max(0, Math.min(displayH, y));

          const origX = x / scale;
          const origY = y / scale;

          return { x: Math.round(origX), y: Math.round(origY) };
        }

      baseImage.addEventListener("mousemove", (event) => {
          if (currentMode !== "hover") return;
          if (!imageId) return;
          if (!baseImage.naturalWidth || !baseImage.naturalHeight) return;
          // æ‚¬åœæ¨¡å¼ç°åœ¨åªåœ¨é¢„å¤„ç†ï¼ˆONNX ç‰¹å¾æå–ï¼‰å®Œæˆåå·¥ä½œï¼Œ
          // ä¸å†èµ°åç«¯æ…¢é€Ÿè·¯å¾„ã€‚
          if (!onnxReady || !hoverUseOnnx) return;

          const coords = getRelativeCoords(event);

          if (lastHoverX !== null && lastHoverY !== null) {
            const dx = coords.x - lastHoverX;
            const dy = coords.y - lastHoverY;
            const dist = Math.hypot(dx, dy);
            if (dist < HOVER_MIN_DISTANCE) {
              return;
            }
          }

          lastHoverX = coords.x;
          lastHoverY = coords.y;

          handleHoverOnnx(coords.x, coords.y);
        });

      baseImage.addEventListener("click", (event) => {
        if (!imageId) return;
        const coords = getRelativeCoords(event);

        if (currentMode === "click") {
          // åŸæ¥çš„ç‚¹å‡»åˆ†å‰²é€»è¾‘
            requestSegmentPoint(coords.x, coords.y);
          return;
        }

        if (currentMode === "hover") {
          // æ‚¬åœæ¨¡å¼ä¸‹ï¼Œç‚¹å‡»å·¦é”®å°†å½“å‰æ‚¬åœé€‰åŒºâ€œå›ºå®šâ€ä¸‹æ¥ï¼š
          // 1. å¦‚æœå½“å‰æ²¡æœ‰é®ç½©ï¼ˆä¾‹å¦‚è¿˜æ²¡æ‚¬åœè¿‡ï¼‰ï¼Œåˆ™å¿½ç•¥ã€‚
          if (!overlayImage.src) return;

          // 2. åŸºäºå½“å‰ overlay å›¾åƒæ„é€ ä¸€ä¸ªå¸¦ 2px ç™½è‰²æè¾¹çš„æœ€ç»ˆé®ç½©ã€‚
          const fullW = baseImage.naturalWidth || overlayImage.naturalWidth;
          const fullH = baseImage.naturalHeight || overlayImage.naturalHeight;
          if (!fullW || !fullH) return;

          const fixedCanvas = document.createElement("canvas");
          fixedCanvas.width = fullW;
          fixedCanvas.height = fullH;
          const ctx = fixedCanvas.getContext("2d");

          // å°†å½“å‰é®ç½©æŒ‰åŸå›¾åˆ†è¾¨ç‡ç»˜åˆ¶åˆ°ç”»å¸ƒä¸Š
          ctx.drawImage(overlayImage, 0, 0, fullW, fullH);

          const imgData = ctx.getImageData(0, 0, fullW, fullH);
          const data = imgData.data;
          const size = fullW * fullH;

          // ä» alpha é€šé“å¾—åˆ°äºŒå€¼ mask
          const mask = new Uint8Array(size);
          for (let i = 0; i < size; i++) {
            const a = data[i * 4 + 3];
            mask[i] = a > 0 ? 1 : 0;
          }

          // è®¡ç®—è¾¹ç¼˜ï¼šmask=1 ä¸”å‘¨å›´å­˜åœ¨ 0 çš„åƒç´ 
          const edge = new Uint8Array(size);
          for (let y = 0; y < fullH; y++) {
            for (let x = 0; x < fullW; x++) {
              const idx = y * fullW + x;
              if (!mask[idx]) continue;
              let isEdge = false;
              for (let dy = -1; dy <= 1 && !isEdge; dy++) {
                for (let dx = -1; dx <= 1 && !isEdge; dx++) {
                  if (dx === 0 && dy === 0) continue;
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx < 0 || nx >= fullW || ny < 0 || ny >= fullH) {
                    isEdge = true;
                    break;
                  }
                  if (!mask[ny * fullW + nx]) {
                    isEdge = true;
                    break;
                  }
                }
              }
              if (isEdge) {
                edge[idx] = 1;
              }
            }
          }

          // å°†è¾¹ç¼˜è†¨èƒ€ä¸€åœˆï¼Œå½¢æˆçº¦ 2px çš„æè¾¹
          const edgeDilated = new Uint8Array(size);
          for (let y = 0; y < fullH; y++) {
            for (let x = 0; x < fullW; x++) {
              let v = 0;
              for (let dy = -1; dy <= 1 && !v; dy++) {
                for (let dx = -1; dx <= 1 && !v; dx++) {
                  const nx = x + dx;
                  const ny = y + dy;
                  if (nx >= 0 && nx < fullW && ny >= 0 && ny < fullH) {
                    if (edge[ny * fullW + nx]) v = 1;
                  }
                }
              }
              edgeDilated[y * fullW + x] = v;
            }
          }

          // åœ¨è¾¹ç¼˜ä½ç½®è¦†ç›–ä¸ºç™½è‰²ï¼ˆå…¶ä½™åŒºåŸŸä¿æŒåŸé®ç½©é¢œè‰²ï¼‰
          for (let i = 0; i < size; i++) {
            if (edgeDilated[i]) {
              const idx4 = i * 4;
              data[idx4] = 255;     // R
              data[idx4 + 1] = 255; // G
              data[idx4 + 2] = 255; // B
              data[idx4 + 3] = 255; // A
            }
          }

          ctx.putImageData(imgData, 0, 0);

          // æ¯æ¬¡ç‚¹å‡»éƒ½ä¼šè¦†ç›– fixedOverlayï¼Œç›¸å½“äºæ¸…ç©ºä¸Šä¸€ä¸ªå›ºå®šé€‰åŒºï¼Œåªä¿ç•™å½“å‰ä¸€ä¸ª
          fixedOverlay.src = fixedCanvas.toDataURL("image/png");
          fixedOverlay.style.display = "block";

          // é¢„è§ˆå±‚æ¸…ç©ºï¼Œåªæ˜¾ç¤ºå›ºå®šå¥½çš„é€‰åŒº
          overlayImage.src = "";
          overlayImage.style.display = "none";

          statusEl.textContent = `å·²å›ºå®šé€‰åŒºï¼Œåæ ‡ (${coords.x}, ${coords.y})`;
        }
      });

      async function handleHoverOnnx(x, y) {
        if (!imageId) return;
        if (hoverInFlight) return;
        if (!onnxReady || !emb0 || !emb1 || !emb2) return;
        if (!origH || !origW || !decoderTargetSize) return;

        hoverInFlight = true;

        try {
          // åœ¨å‰ç«¯è‡ªè¡Œåšåæ ‡å½’ä¸€åŒ–ï¼šx' = x * (target_size / origW), y' = y * (target_size / origH)
          const sx = decoderTargetSize / origW;
          const sy = decoderTargetSize / origH;
          const nx = x * sx;
          const ny = y * sy;

          const normPoints = [[[[nx, ny]]]];
          const normLabels = [[[1]]];

          const pred = await decodePointONNX(normPoints, normLabels);
          if (!pred) {
            hoverInFlight = false;
            return;
          }

          // pred: [1, 1, 1, H, W]
          const H = pred.dims[3];
          const W = pred.dims[4];
          const data = pred.data;

          // logits -> ç²—äºŒå€¼ mask
          const bin = new Uint8Array(H * W);
          for (let i = 0; i < H * W; i++) {
            bin[i] = data[i] > 0 ? 1 : 0;
          }

          // ç®€å• 3x3 é—­è¿ç®—ï¼Œå¹³æ»‘è¾¹ç¼˜ & å¡«å°æ´
          function dilate(src, w, h) {
            const dst = new Uint8Array(src.length);
            for (let y = 0; y < h; y++) {
              for (let x = 0; x < w; x++) {
                let v = 0;
                for (let dy = -1; dy <= 1 && !v; dy++) {
                  for (let dx = -1; dx <= 1 && !v; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                      if (src[ny * w + nx]) v = 1;
                    }
                  }
                }
                dst[y * w + x] = v;
              }
            }
            return dst;
          }

          function erode(src, w, h) {
            const dst = new Uint8Array(src.length);
            for (let y = 0; y < h; y++) {
              for (let x = 0; x < w; x++) {
                let v = 1;
                for (let dy = -1; dy <= 1 && v; dy++) {
                  for (let dx = -1; dx <= 1 && v; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                      if (!src[ny * w + nx]) v = 0;
                    }
                  }
                }
                dst[y * w + x] = v;
              }
            }
            return dst;
          }

          let smooth = dilate(bin, W, H);
          smooth = erode(smooth, W, H);

          // å…ˆåœ¨ä¸€ä¸ªå° canvas ä¸Šç»˜åˆ¶ä½åˆ†è¾¨ç‡ maskï¼Œ
          // å†æŠŠå®ƒæŒ‰åŸå›¾æ¯”ä¾‹æ‹‰ä¼¸åˆ°ä¸åŸå›¾ç›¸åŒçš„å®½é«˜ï¼Œé¿å…åœ¨ 16:9 ç”»å¸ƒé‡Œè¢«é¢å¤–æ‹‰ä¼¸ã€‚
          const maskData = new Uint8ClampedArray(H * W * 4);
          for (let i = 0; i < H * W; i++) {
            const v = smooth[i];
            const idx = i * 4;
            maskData[idx] = 30;
            maskData[idx + 1] = 144;
            maskData[idx + 2] = 255;
            maskData[idx + 3] = v ? 160 : 0;
          }

          // ä½åˆ†è¾¨ç‡ mask ç”»å¸ƒ
          const maskCanvas = document.createElement("canvas");
          maskCanvas.width = W;
          maskCanvas.height = H;
          const mctx = maskCanvas.getContext("2d");
          const imgData = new ImageData(maskData, W, H);
          mctx.putImageData(imgData, 0, 0);

          // ä¸åŸå›¾ç›¸åŒå®½é«˜çš„ç”»å¸ƒï¼ˆä½¿ç”¨ naturalWidth/Heightï¼Œä¿æŒä¸æœåŠ¡å™¨è¿”å›çš„ overlay ä¸€è‡´ï¼‰
          const fullCanvas = document.createElement("canvas");
          const fullW = baseImage.naturalWidth || W;
          const fullH = baseImage.naturalHeight || H;
          fullCanvas.width = fullW;
          fullCanvas.height = fullH;
          const fctx = fullCanvas.getContext("2d");
          fctx.drawImage(maskCanvas, 0, 0, fullW, fullH);

          overlayImage.src = fullCanvas.toDataURL("image/png");
          overlayImage.style.display = "block";
          statusEl.textContent = `ONNX æ‚¬åœåˆ†å‰²åæ ‡: (${x}, ${y})`;
        } catch (err) {
          console.error(err);
        } finally {
          hoverInFlight = false;
        }
      }
      async function requestSegmentPoint(x, y) {
        const currentRequestId = ++lastRequestId;
        statusEl.textContent = `ç‚¹å‡»åæ ‡: (${x}, ${y})ï¼Œè¯·æ±‚ä¸­...`;

        try {
          const res = await fetch(`${apiBase()}/segment_point`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image_id: imageId, x, y }),
          });
          if (!res.ok) {
            statusEl.textContent = "å½“å‰ç‚¹æœªæ£€æµ‹åˆ°ç›®æ ‡ã€‚";
            clearOverlay();
            return;
          }
          const json = await res.json();

          if (currentRequestId !== lastRequestId) {
            // æœ‰æ›´æ–°çš„è¯·æ±‚å‘å‡ºï¼Œè¿™æ¬¡ç»“æœä¸¢å¼ƒ
            return;
          }

          overlayImage.src = json.image;
          overlayImage.style.display = "block";
          statusEl.textContent = `å·²æ›´æ–°é€‰åŒºï¼Œåæ ‡ (${x}, ${y})`;
        } catch (err) {
          console.error(err);
          setServerOnline(false);
          statusEl.textContent = "è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯ã€‚";
        }
      }



      modeButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          modeButtons.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentMode = btn.dataset.mode;
          // æ¨¡å¼åˆ‡æ¢æ—¶ï¼Œä¸¢å¼ƒä¹‹å‰çš„æ‚¬åœè¯·æ±‚ï¼Œé¿å…æ—§å“åº”åœ¨æ–°æ¨¡å¼ä¸‹ç”Ÿæ•ˆ
          lastRequestId++;
          hoverInFlight = false;
          textControls.classList.toggle("hidden", currentMode !== "text");
          clearOverlay();
          if (currentMode === "text") {
            statusEl.textContent =
              "è¾“å…¥æ–‡æœ¬æç¤ºåç‚¹å‡»â€œè¿è¡Œæ–‡å­—åˆ†å‰²â€ã€‚";
          }
        });
      });

      runTextButton.addEventListener("click", async () => {
        if (!imageId) {
          statusEl.textContent = "è¯·å…ˆä¸Šä¼ å›¾ç‰‡ã€‚";
          return;
        }
        const text = promptInput.value.trim();
        if (!text) {
          statusEl.textContent = "æ–‡æœ¬æç¤ºä¸èƒ½ä¸ºç©ºã€‚";
          return;
        }
        statusEl.textContent = "æ–‡å­—åˆ†å‰²ä¸­...";

        try {
          const res = await fetch(`${apiBase()}/segment_text`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ image_id: imageId, text }),
          });
          if (!res.ok) {
            statusEl.textContent =
              "æ–‡å­—åˆ†å‰²å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æ—¥å¿—ã€‚";
            return;
          }
          const json = await res.json();
          overlayImage.src = json.image;
          overlayImage.style.display = "block";
          statusEl.textContent = "æ–‡å­—åˆ†å‰²å®Œæˆã€‚";
        } catch (err) {
          console.error(err);
          setServerOnline(false);
          statusEl.textContent = "è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯ã€‚";
        }
      });

    </script>
  </body>
</html>
